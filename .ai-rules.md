# Forklaunch Platform - Universal AI Rules
Quick reference for any AI assistant (Claude Code, Cursor, Windsurf, Cline, Copilot, Devin, etc.)

## üö® Critical Rules

### 1. Import from @forklaunch Packages (NOT @modules/core)
```typescript
‚úÖ CORRECT:
import { isRecord } from '@forklaunch/common';
import { OpenTelemetryCollector } from '@forklaunch/core/http';
import { SchemaValidator } from '@forklaunch/validator/zod';
import { forklaunchExpress } from '@forklaunch/express';

‚ùå WRONG:
import { isRecord } from '@modules/core';  // NEVER!
```

### 2. Mappers: Controllers YES, Services NO
```typescript
‚úÖ In Controllers (api/controllers/*.controller.ts):
return res.json(DeploymentMapper.toDetailDto(deployment));

‚ùå In Services (domain/services/*.service.ts):
return DeploymentMapper.toDetailDto(deployment);  // NO!

‚úÖ Services Return Entities:
async findById(id: string): Promise<Deployment> {
  return this.em.findOne(Deployment, { id });
}
```

### 3. CLI Commands (Never Edit Manifest Manually)
```bash
‚ùå vim .forklaunch/manifest.toml  # NEVER!

‚úÖ forklaunch change application --runtime bun --dry-run
‚úÖ forklaunch change application --runtime bun

‚úÖ forklaunch init service billing --database postgresql
‚úÖ forklaunch init worker email-worker --type bullmq
```

## Import Organization (7 Layers)

```typescript
// 1. Node built-ins (use node: prefix)
import crypto from 'node:crypto';
import path from 'node:path';

// 2. External dependencies
import { EntityManager } from '@mikro-orm/core';
import { injectable } from 'tsyringe';
import type { Redis } from 'ioredis';

// 3. Forklaunch framework packages
import { isRecord } from '@forklaunch/common';
import { OpenTelemetryCollector } from '@forklaunch/core/http';
import { forklaunchExpress, handlers } from '@forklaunch/express';
import { SchemaValidator, string, uuid } from '@forklaunch/validator/zod';
import { ForklaunchWebSocket } from '@forklaunch/ws';
import { S3ObjectStore } from '@forklaunch/infrastructure-s3';

// 4. Cross-module imports (from other modules in monorepo)
import type { DeploymentAgentWorkerSdkClient } from '@forklaunch-platform/deployment-agent-worker';
import { generateHmacAuthHeaders } from '@forklaunch-platform/iam';

// 5. Local persistence layer
import {
  Application,
  Deployment,
  Environment
} from '../../persistence/entities';

// 6. Local domain layer
import { DeploymentStatusEnum } from '../enum/deployment-status.enum';
import type { PulumiOutputs } from '../types/aws.types';
import { S3Keys } from '../utils/s3-keys.util';

// 7. Same directory
import { DeploymentService } from './deployment.service';
import { EncryptionService } from './encryption.service';
```

## Project Structure

```
src/modules/<module-name>/
‚îú‚îÄ‚îÄ api/                     # HTTP interface layer
‚îÇ   ‚îú‚îÄ‚îÄ controllers/        # Request handlers (use mappers here)
‚îÇ   ‚îú‚îÄ‚îÄ routes/            # Route definitions
‚îÇ   ‚îú‚îÄ‚îÄ middleware/        # Middleware
‚îÇ   ‚îî‚îÄ‚îÄ utils/             # API utilities
‚îú‚îÄ‚îÄ domain/                 # Business logic layer
‚îÇ   ‚îú‚îÄ‚îÄ services/          # Core business logic (NO mappers)
‚îÇ   ‚îú‚îÄ‚îÄ schemas/           # Validation schemas (Zod/TypeBox)
‚îÇ   ‚îú‚îÄ‚îÄ types/             # TypeScript types
‚îÇ   ‚îú‚îÄ‚îÄ mappers/           # Entity ‚Üî DTO transformations
‚îÇ   ‚îú‚îÄ‚îÄ enum/              # Enumerations
‚îÇ   ‚îú‚îÄ‚îÄ constants/         # Constants
‚îÇ   ‚îú‚îÄ‚îÄ guards/            # Type guards
‚îÇ   ‚îî‚îÄ‚îÄ utils/             # Domain utilities
‚îú‚îÄ‚îÄ persistence/            # Data layer
‚îÇ   ‚îú‚îÄ‚îÄ entities/          # Database models (MikroORM)
‚îÇ   ‚îî‚îÄ‚îÄ seeders/           # Test data
‚îú‚îÄ‚îÄ migrations-postgresql/  # Database migrations
‚îú‚îÄ‚îÄ websocket/             # WebSocket handlers
‚îú‚îÄ‚îÄ registrations.ts       # Dependency injection setup
‚îî‚îÄ‚îÄ server.ts              # Service entry point
```

## File Naming Conventions

| Type | Pattern | Example |
|------|---------|---------|
| Controller | `*.controller.ts` | `deployment.controller.ts` |
| Service | `*.service.ts` | `deployment.service.ts` |
| Entity | `*.entity.ts` | `deployment.entity.ts` |
| Schema | `*.schema.ts` | `deployment.schema.ts` |
| Types | `*.types.ts` | `deployment.types.ts` |
| Mapper | `*.mappers.ts` | `deployment.mappers.ts` |
| Routes | `*.routes.ts` | `deployment.routes.ts` |
| Test | `*.test.ts` | `deployment.service.test.ts` |

## When to Use Mappers

| Scenario | Use Mapper? | Where? |
|----------|-------------|--------|
| Controller ‚Üí API response | ‚úÖ YES | Controllers |
| Service ‚Üí Service call | ‚ùå NO | Services |
| External API | ‚úÖ YES | Controllers |
| Internal communication | ‚ùå NO | Services |
| Complex transformation | ‚úÖ YES | Controllers |
| Simple pass-through | ‚ùå NO | Inline |

## Cache Pattern (TTL-based with Redis)

```typescript
import { createCacheKey, TtlCache } from '@forklaunch/core/cache';
import { RedisTtlCache } from '@forklaunch/infrastructure-redis';

// Create cache with 60s default TTL
const cache = new RedisTtlCache(
  60000, // 60 seconds
  openTelemetryCollector,
  { url: 'redis://localhost:6379' }
);

// Create typed cache keys
const createUserKey = createCacheKey('user');
const createSessionKey = createCacheKey('session');

// Put with custom TTL (5 minutes)
await cache.putRecord({
  key: createUserKey('123'),
  value: { name: 'Alice', email: 'alice@example.com' },
  ttlMilliseconds: 300000
});

// Read
const user = await cache.readRecord(createUserKey('123'));

// Delete
await cache.deleteRecord(createUserKey('123'));
```

## Object Store Pattern (S3 for Large Files)

```typescript
import { createObjectStoreKey, ObjectStore } from '@forklaunch/core/objectstore';
import { S3ObjectStore } from '@forklaunch/infrastructure-s3';

// Create object store
const store = new S3ObjectStore({
  region: 'us-east-1',
  bucketName: 'my-app-uploads',
  openTelemetryCollector
});

// Create typed keys
const createUserFileKey = createObjectStoreKey('user-files');

// Upload object
await store.putObject({
  key: createUserFileKey('123', 'avatar.png'),
  value: buffer,
  metadata: { contentType: 'image/png' }
});

// Download object
const file = await store.readObject(createUserFileKey('123', 'avatar.png'));

// Stream large files
const stream = await store.streamDownloadObject(createUserFileKey('123', 'video.mp4'));
```

## WebSocket Pattern (Type-Safe)

```typescript
import { ForklaunchWebSocketServer, EventSchema } from '@forklaunch/ws';
import { SchemaValidator } from '@forklaunch/validator/zod';
import { z } from 'zod';

const validator = SchemaValidator();
const schemas: EventSchema<typeof validator> = {
  ping: { shape: z.object({ ts: z.number() }) },
  pong: { shape: z.object({ ts: z.number() }) },
  clientMessages: {
    chat: {
      shape: z.object({
        type: z.literal('chat'),
        message: z.string(),
        roomId: z.string()
      })
    }
  },
  serverMessages: {
    chatMessage: {
      shape: z.object({
        type: z.literal('chatMessage'),
        message: z.string(),
        userId: z.string(),
        timestamp: z.number()
      })
    }
  }
};

const wss = new ForklaunchWebSocketServer(validator, schemas, { port: 8080 });

wss.on('connection', (ws) => {
  ws.on('message', (data) => {
    // data is typed and validated!
    if (data.type === 'chat') {
      // Broadcast to room
      wss.clients.forEach(client => {
        client.send({
          type: 'chatMessage',
          message: data.message,
          userId: '123',
          timestamp: Date.now()
        });
      });
    }
  });
});
```

## Testing Pattern (TestContainers)

```typescript
import { BlueprintTestHarness, TEST_TOKENS, clearTestDatabase } from '@forklaunch/testing';

let harness: BlueprintTestHarness;
let setup: TestSetupResult;

beforeAll(async () => {
  harness = new BlueprintTestHarness({
    getConfig: async () => {
      const { default: config } = await import('../mikro-orm.config');
      return config;
    },
    databaseType: 'postgres',
    useMigrations: false,
    needsRedis: true,
    needsS3: true,
    s3Bucket: 'test-uploads'
  });

  setup = await harness.setup();
}, 60000);

afterAll(async () => {
  await harness.cleanup();
}, 30000);

beforeEach(async () => {
  await clearTestDatabase({ orm: setup.orm });
});

it('should create user', async () => {
  const response = await createUserRoute.sdk.createUser({
    body: { email: 'test@example.com', name: 'Test' },
    headers: { authorization: TEST_TOKENS.AUTH }
  });

  expect(response.code).toBe(201);
});
```

## Utility Functions

```typescript
import {
  toCamelCaseIdentifier,
  toPrettyCamelCase,
  isValidIdentifier,
  isRecord,
  deepCloneWithoutUndefined,
  hashString
} from '@forklaunch/common';

// String utilities
toCamelCaseIdentifier('hello-world');  // 'helloWorld'
toPrettyCamelCase('API-Key');          // 'apiKey'
isValidIdentifier('myVar123');         // true

// Object utilities
isRecord(value);                       // Type guard for objects
deepCloneWithoutUndefined(obj);        // Deep clone without undefined props
hashString('my-string');                // SHA-256 hash

// Persistence utilities
import { BaseEntity } from '@forklaunch/core/persistence';

class User extends BaseEntity {
  @PrimaryKey() id!: string;
  @Property() name!: string;
}

// Create with EntityManager (recommended)
const user = await User.create({ id: '123', name: 'Alice' }, em);

// Update existing
const updated = await User.update({ id: '123', name: 'Bob' }, em);
await em.flush();

// Read as DTO
const dto = await user.read(em);
```

## Common CLI Commands

```bash
# Project Management
forklaunch init application <name>
forklaunch init service <name> --database postgresql
forklaunch init worker <name> --type bullmq
forklaunch init library <name>
forklaunch delete service <name>
forklaunch delete worker <name>

# Modify Projects (ALWAYS dry-run first)
forklaunch change application --runtime bun --dry-run
forklaunch change application --runtime bun
forklaunch change service <name> --database mysql

# Sync Projects
forklaunch sync all                    # Sync all projects
forklaunch sync service <name>         # Sync specific service
forklaunch sync worker <name>          # Sync specific worker

# Environment Variables
forklaunch environment validate         # Check for missing vars
forklaunch env validate                # Alias
forklaunch environment sync            # Add missing vars with blank values
forklaunch env sync --dry-run          # Preview changes

# SDK Management
forklaunch sdk mode --type generated   # Use pre-generated types (production)
forklaunch sdk mode --type live        # Use live types (development)
forklaunch sdk mode --type generated --dryrun  # Preview changes

# OpenAPI
forklaunch openapi export              # Export to .forklaunch/openapi/
forklaunch openapi export --output ./docs/api

# Deployment
forklaunch integrate --app <app-id>    # Link to platform
forklaunch release create --version 1.2.3
forklaunch deploy create --release v1.2.3 --environment staging --region us-east-1
forklaunch deploy destroy --environment staging --region us-east-1 --mode preserve-data
```

## Route Definition Pattern

```typescript
import { forklaunchExpress } from '@forklaunch/express';
import { SchemaValidator, string, uuid } from '@forklaunch/validator/zod';

const validator = SchemaValidator();
const app = forklaunchExpress(validator, openTelemetryCollector);

app.post('/deployments', {
  name: 'Create Deployment',
  summary: 'Creates a new deployment',
  body: {
    applicationId: uuid,
    environmentId: uuid
  },
  responses: {
    201: { id: uuid, status: string, createdAt: string },
    400: { error: string },
    401: { error: string }
  }
}, async (req, res) => {
  const deployment = await service.create(req.body);
  return res.status(201).json(deployment);
});
```

## WebSocket Pattern

```typescript
import { ForklaunchWebSocketServer } from '@forklaunch/ws';
import { SchemaValidator } from '@forklaunch/validator/zod';
import { z } from 'zod';

const validator = SchemaValidator();
const schemas = {
  clientMessages: z.object({ type: z.string(), data: z.any() }),
  serverMessages: z.object({ type: z.string(), data: z.any() }),
  ping: z.object({ timestamp: z.number() }),
  pong: z.object({ timestamp: z.number() }),
  errors: z.object({ code: z.string(), message: z.string() }),
  closeReason: z.object({ reason: z.string() })
};

const wss = new ForklaunchWebSocketServer(validator, schemas, { port: 8080 });

wss.on('connection', (ws) => {
  ws.on('message', (data) => {
    // data is typed and validated!
  });
});
```

## DDD Layer Responsibilities

### Controllers (api/controllers/)
- ‚úÖ Handle HTTP requests
- ‚úÖ Use mappers to format responses
- ‚úÖ Validate input (Zod schemas)
- ‚ùå NO business logic

### Services (domain/services/)
- ‚úÖ Business logic
- ‚úÖ Return entities
- ‚úÖ Coordinate operations
- ‚ùå NO mappers
- ‚ùå NO HTTP concerns

### Entities (persistence/entities/)
- ‚úÖ Database models
- ‚úÖ MikroORM decorators
- ‚úÖ Relationships

### Mappers (domain/mappers/)
- ‚úÖ Entity ‚Üí DTO
- ‚úÖ Used by controllers
- ‚ùå NOT used by services

## Safe Change Workflow

```bash
# 1. Commit current state
git add . && git commit -m "Before change"

# 2. Preview with dry-run
forklaunch change application --runtime bun --dry-run

# 3. Apply change
forklaunch change application --runtime bun

# 4. Install and test
pnpm install
pnpm test
pnpm dev

# 5. Commit changes
git add . && git commit -m "Changed to Bun runtime"
```

## Testing Patterns

```typescript
// Unit Test (Mock Dependencies)
describe('DeploymentService', () => {
  let service: DeploymentService;
  let mockRepo: jest.Mocked<DeploymentRepository>;

  beforeEach(() => {
    mockRepo = { findOne: jest.fn() } as any;
    service = new DeploymentService(mockRepo);
  });

  it('should find deployment', async () => {
    mockRepo.findOne.mockResolvedValue({ id: '123' });
    const result = await service.findById('123');
    expect(result.id).toBe('123');
  });
});

// Integration Test (TestContainers + Real Database)
import { BlueprintTestHarness, TEST_TOKENS, clearTestDatabase } from '@forklaunch/testing';

describe('User API Integration Tests', () => {
  let harness: BlueprintTestHarness;
  let setup: TestSetupResult;

  beforeAll(async () => {
    harness = new BlueprintTestHarness({
      getConfig: async () => {
        const { default: config } = await import('../mikro-orm.config');
        return config;
      },
      databaseType: 'postgres',
      useMigrations: false,      // Fast: schema generation
      needsRedis: true,          // Optional: add Redis container
      needsS3: true,             // Optional: add S3 (LocalStack) container
      s3Bucket: 'test-uploads'
    });

    setup = await harness.setup();
  }, 60000);  // 60s timeout for container startup

  afterAll(async () => {
    await harness.cleanup();   // Clean up containers
  }, 30000);

  beforeEach(async () => {
    // Clear database between tests for isolation
    await clearTestDatabase({ orm: setup.orm });

    // Seed test data
    const em = setup.orm!.em.fork();
    em.create(User, { id: '123', email: 'test@example.com', name: 'Test User' });
    await em.flush();
  });

  it('should create user with AUTH token', async () => {
    const response = await createUserRoute.sdk.createUser({
      body: { email: 'new@example.com', name: 'New User' },
      headers: { authorization: TEST_TOKENS.AUTH }
    });

    expect(response.code).toBe(201);
    expect(response.response.email).toBe('new@example.com');
  });

  it('should create subscription with HMAC token', async () => {
    const response = await createSubscriptionRoute.sdk.createSubscription({
      body: {
        partyId: '123',
        partyType: 'USER',
        productId: 'prod-456'
      },
      headers: { authorization: TEST_TOKENS.HMAC }
    });

    expect(response.code).toBe(201);
  });
});
```

## Key Principles

1. **Import from @forklaunch packages** - Never @modules/core
2. **Use CLI for all changes** - Never edit manifest.toml
3. **Mappers in controllers only** - Services return entities
4. **7-layer import organization** - Follow the standard order
5. **DDD layer separation** - api ‚Üí domain ‚Üí persistence
6. **Type safety** - Leverage TypeScript and Zod schemas
7. **Convention over configuration** - Follow naming patterns

## Common Mistakes to Avoid

‚ùå Importing from `@modules/core`
‚ùå Using mappers in service layer
‚ùå Manually editing manifest.toml
‚ùå Skipping `--dry-run` for changes
‚ùå Not organizing imports in 7 layers
‚ùå Putting business logic in controllers
‚ùå Passing DTOs between internal services
‚ùå Inconsistent file naming

---

**Complete Documentation:**
- `.claude/skills/` - Full skills for Claude Code
- `docs/development/` - Human-readable guides
- https://forklaunch.com/docs - Online documentation
