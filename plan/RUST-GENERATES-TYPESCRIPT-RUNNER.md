# Rust CLI Generates TypeScript Runner for OpenAPI

**Concept**: CLI generates a temporary TypeScript file that calls the framework's existing OpenAPI generation, then executes it.

## How It Works

### Current Framework Code (Already Working!)

The framework already has OpenAPI generation in `listen()`:

```typescript
// framework/express/src/expressApplication.ts (line 135-154)
listen(...args: unknown[]): Server {
  if (process.env.FORKLAUNCH_MODE === 'openapi') {
    const openApiSpec = generateOpenApiSpecs<SV>(
      this.schemaValidator,
      [],
      [],
      this,
      this.openapiConfiguration
    );
    fs.writeFileSync(
      process.env.FORKLAUNCH_OPENAPI_OUTPUT as string,
      JSON.stringify({
        ...openApiSpec,
        '': openApiSpec[OPENAPI_DEFAULT_VERSION]
      }, null, 2)
    );
    process.exit(0);
  }
  
  // Normal server startup...
}
```

**Key insight**: The framework **already generates versioned OpenAPI** when you call `listen()` in OpenAPI mode!

---

## Solution: Generate Runner Script

### CLI generates this TypeScript file:

```typescript
// .forklaunch-tmp/openapi-runner.ts (generated by Rust CLI)

// Import the service setup
import { app } from '../src/modules/iam-base/server';

// Set environment variables
process.env.FORKLAUNCH_MODE = 'openapi';
process.env.FORKLAUNCH_OPENAPI_OUTPUT = './dist/iam-base/openapi.json';
process.env.DOTENV_FILE_PATH = '.env.local';

// Call listen() - this triggers OpenAPI generation and exits
app.listen();
```

### CLI runs it:

```bash
pnpm tsx .forklaunch-tmp/openapi-runner.ts
```

That's it! The framework handles everything.

---

## Rust CLI Implementation

### Update: `cli/src/core/openapi_export.rs`

```rust
use anyhow::{Context, Result, bail};
use serde_json::Value;
use std::{
    collections::HashMap,
    fs::{create_dir_all, write, remove_file},
    path::Path,
};
use std::process::Command;

#[derive(Debug)]
enum PackageManager {
    Pnpm,
    Bun,
    Npm,
}

fn detect_package_manager(app_root: &Path) -> Result<PackageManager> {
    if app_root.join("pnpm-lock.yaml").exists() {
        Ok(PackageManager::Pnpm)
    } else if app_root.join("bun.lockb").exists() {
        Ok(PackageManager::Bun)
    } else {
        Ok(PackageManager::Npm)
    }
}

pub fn export_all_services(
    app_root: &Path,
    manifest: &ApplicationManifestData,
    dist_path: &Path,
) -> Result<HashMap<String, HashMap<String, Value>>> {
    let mut all_specs = HashMap::new();
    let package_manager = detect_package_manager(app_root)?;
    
    // Create temp directory for runner scripts
    let temp_dir = app_root.join(".forklaunch-tmp");
    create_dir_all(&temp_dir)?;
    
    for project in &manifest.projects {
        if project.r#type != ProjectType::Service {
            continue;
        }
        
        let service_dist = dist_path.join(&project.name);
        create_dir_all(&service_dist)?;
        
        let output_path = service_dist.join("openapi.json");
        let runner_path = temp_dir.join(format!("{}-runner.ts", project.name));
        
        // âœ… Generate TypeScript runner script
        let runner_script = generate_runner_script(
            &manifest.modules_path,
            &project.name,
        )?;
        
        write(&runner_path, runner_script)?;
        
        // âœ… Execute the runner script with env vars set BEFORE import
        let status = match package_manager {
            PackageManager::Pnpm => {
                Command::new("pnpm")
                    .args(&["tsx", runner_path.to_str().unwrap()])
                    .current_dir(app_root)
                    .env("FORKLAUNCH_MODE", "openapi")  // âœ… Set BEFORE import
                    .env("FORKLAUNCH_OPENAPI_OUTPUT", output_path.to_str().unwrap())
                    .env("DOTENV_FILE_PATH", ".env.local")
                    .status()?
            },
            PackageManager::Bun => {
                Command::new("bun")
                    .args(&[runner_path.to_str().unwrap()])
                    .current_dir(app_root)
                    .env("FORKLAUNCH_MODE", "openapi")
                    .env("FORKLAUNCH_OPENAPI_OUTPUT", output_path.to_str().unwrap())
                    .env("DOTENV_FILE_PATH", ".env.local")
                    .status()?
            },
            PackageManager::Npm => {
                Command::new("npx")
                    .args(&["tsx", runner_path.to_str().unwrap()])
                    .current_dir(app_root)
                    .env("FORKLAUNCH_MODE", "openapi")
                    .env("FORKLAUNCH_OPENAPI_OUTPUT", output_path.to_str().unwrap())
                    .env("DOTENV_FILE_PATH", ".env.local")
                    .status()?
            },
        };
        
        if !status.success() {
            bail!("Failed to export OpenAPI for {}", project.name);
        }
        
        // Read the generated OpenAPI file
        let content = std::fs::read_to_string(&output_path)
            .with_context(|| format!("Failed to read OpenAPI output for {}", project.name))?;
        
        let versioned_specs: HashMap<String, Value> = serde_json::from_str(&content)
            .with_context(|| format!("Failed to parse OpenAPI output for {}", project.name))?;
        
        all_specs.insert(project.name.clone(), versioned_specs);
        
        // Clean up runner script
        let _ = remove_file(&runner_path);
    }
    
    // Clean up temp directory if empty
    let _ = std::fs::remove_dir(&temp_dir);
    
    Ok(all_specs)
}

fn generate_runner_script(
    modules_path: &str,
    service_name: &str,
) -> Result<String> {
    let relative_server_path = format!("../{}/{}/server", modules_path, service_name);
    
    let script = format!(r#"
// Auto-generated OpenAPI runner for {service_name}
// This file is temporary and will be deleted after execution
// Environment variables are set by the CLI before this runs

import {{ app }} from '{relative_server_path}';

// Trigger OpenAPI generation
// The framework intercepts listen() and generates OpenAPI instead
// FORKLAUNCH_MODE is already set by the CLI before import
app.listen();
"#,
        service_name = service_name,
        relative_server_path = relative_server_path,
    );
    
    Ok(script)
}
```

---

## How It Works

### Step 1: CLI Generates Runner

```rust
// For service "iam-base", generates:
.forklaunch-tmp/iam-base-runner.ts
```

**Contents** (simplified - env vars set by CLI):
```typescript
// Environment variables are set by CLI before this runs
import { app } from '../src/modules/iam-base/server';

app.listen();  // Framework intercepts and generates OpenAPI
```

### Step 2: CLI Executes Runner with Env Vars

**Critical**: Env vars must be set **before** the import happens!

```rust
Command::new("pnpm")
    .args(&["tsx", ".forklaunch-tmp/iam-base-runner.ts"])
    .env("FORKLAUNCH_MODE", "openapi")  // âœ… Set BEFORE import
    .env("FORKLAUNCH_OPENAPI_OUTPUT", "./dist/iam-base/openapi.json")
    .env("DOTENV_FILE_PATH", ".env.local")
    .status()?
```

### Step 3: Framework Generates OpenAPI

**Execution order** (with env vars set before import):

1. CLI sets `FORKLAUNCH_MODE=openapi` environment variable
2. CLI runs `pnpm tsx runner.ts`
3. Runner imports `server.ts`
   - ConfigInjector sees `FORKLAUNCH_MODE=openapi`
   - ConfigInjector returns `{}` for all dependencies
   - Controllers get empty objects (which they never use)
4. Service registers routes (via `app.register()`)
5. Runner calls `app.listen()`
6. Framework sees `FORKLAUNCH_MODE=openapi` in listen()
7. Framework calls `generateOpenApiSpecs()` from registered routes
8. Framework writes versioned JSON to output file
9. Framework exits (process.exit(0))

**No instantiation errors** because configInjector skips all dependency resolution! âœ…

### Step 4: CLI Reads Output

```rust
let content = read_to_string(&output_path)?;
let versioned_specs: HashMap<String, Value> = serde_json::from_str(&content)?;
```

### Step 5: CLI Cleans Up

```rust
remove_file(&runner_path)?;
```

---

## Benefits

### 1. âœ… Reuses Framework Code
- No duplication
- Guaranteed identical output
- Framework already handles versioning
- Framework already converts schemas

### 2. âœ… Simple Implementation
- CLI just generates a script
- ~50 lines of Rust code
- No complex parsing

### 3. âœ… Works Today
- Framework already has the logic
- configInjector already skips dependencies
- Just need to call `listen()`

### 4. âœ… Clean
- Temp files auto-cleaned
- No permanent artifacts
- Self-contained

---

## Framework Update Needed

The framework currently outputs:
```json
{
  "v1": { ... },
  "": { ... }  // Default version duplicated
}
```

Should be:
```json
{
  "v1": { ... },
  "v2": { ... }
}
```

**Fix in framework** (`expressApplication.ts` line 143-152):

```typescript
if (process.env.FORKLAUNCH_MODE === 'openapi') {
  const openApiSpec = generateOpenApiSpecs<SV>(
    this.schemaValidator,
    [],
    [],
    this,
    this.openapiConfiguration
  );
  
  fs.writeFileSync(
    process.env.FORKLAUNCH_OPENAPI_OUTPUT as string,
    JSON.stringify(openApiSpec, null, 2)  // âœ… Just output the versioned specs
  );
  process.exit(0);
}
```

Remove the `{ ...openApiSpec, '': openApiSpec[OPENAPI_DEFAULT_VERSION] }` wrapping.

---

## Critical: Environment Variable Ordering

### âŒ Wrong Approach (Instantiation Errors)

```typescript
// runner.ts
import { app } from '../server';  // âš ï¸ Import happens first!

process.env.FORKLAUNCH_MODE = 'openapi';  // âŒ TOO LATE!
app.listen();
```

**Problem**: When `import` runs, it executes `server.ts` which tries to instantiate services. ConfigInjector doesn't see the mode yet, so it tries to initialize MikroORM, Redis, etc. â†’ **Errors in CI!**

### âœ… Correct Approach (No Errors)

```rust
// Set env vars in the Command, BEFORE running the script
Command::new("pnpm")
    .args(&["tsx", "runner.ts"])
    .env("FORKLAUNCH_MODE", "openapi")  // âœ… Set BEFORE import
    .status()?
```

```typescript
// runner.ts (env already set)
import { app } from '../server';  // âœ… ConfigInjector sees mode, skips dependencies

app.listen();
```

**Why this works**: Node.js inherits environment variables from the parent process. When tsx starts, `FORKLAUNCH_MODE` is already set, so the import sees it immediately.

**Result**: ConfigInjector skips ALL dependency resolution during import â†’ No database, Redis, or any external services needed! âœ…

---

## Example Generated Runner

For the billing service:

```typescript
// .forklaunch-tmp/billing-base-runner.ts
// Environment variables are set by CLI before this runs

import { app } from '../src/modules/billing-base/server';

// Trigger OpenAPI generation
// FORKLAUNCH_MODE is already set, so framework intercepts listen()
app.listen();
```

**Executed with**:
```rust
Command::new("pnpm")
    .args(&["tsx", ".forklaunch-tmp/billing-base-runner.ts"])
    .env("FORKLAUNCH_MODE", "openapi")
    .env("FORKLAUNCH_OPENAPI_OUTPUT", "./dist/billing-base/openapi.json")
    .env("DOTENV_FILE_PATH", ".env.local")
    .status()?
```

**Output** (`dist/billing-base/openapi.json`):
```json
{
  "v1": {
    "openapi": "3.1.0",
    "info": { "title": "billing-base", "version": "v1" },
    "paths": {
      "/subscriptions": { ... },
      "/payment-links": { ... }
    }
  }
}
```

---

## Testing

```bash
cd my-forklaunch-app

# Manual test of generated runner
cat > .forklaunch-tmp/test-runner.ts << 'EOF'
import { app } from './src/modules/iam-base/server';

process.env.FORKLAUNCH_MODE = 'openapi';
process.env.FORKLAUNCH_OPENAPI_OUTPUT = './test-openapi.json';
process.env.DOTENV_FILE_PATH = '.env.local';

app.listen();
EOF

pnpm tsx .forklaunch-tmp/test-runner.ts

# Should generate test-openapi.json with versioned specs
cat test-openapi.json
```

---

## Complete Flow

```
User runs: forklaunch release create --version 1.0.0

CLI:
  1. For each service:
     a. Generate runner script (.forklaunch-tmp/iam-base-runner.ts)
     b. Execute: pnpm tsx .forklaunch-tmp/iam-base-runner.ts
     c. Read output: dist/iam-base/openapi.json
     d. Parse versioned specs
     e. Clean up runner script
  
  2. Collect all versioned specs:
     {
       "iam-base": { "v1": {...}, "v2": {...} },
       "billing-base": { "v1": {...} }
     }
  
  3. Upload to platform
```

---

## Summary

**Approach**: CLI generates TypeScript runners that call the framework's existing OpenAPI generation.

**Advantages**:
- âœ… Reuses existing framework code (no duplication)
- âœ… Guaranteed identical output
- âœ… Simple to implement (~50 lines Rust)
- âœ… Works with configInjector fix
- âœ… Self-cleaning (temp files removed)

**Implementation Time**: ~2 hours

**This is the cleanest solution!** ðŸŽ‰

